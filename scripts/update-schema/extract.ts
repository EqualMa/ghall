import { strict as assert } from "assert";
import * as gq from "graphql";
import * as e from "./extractors";

const defsToExtract: Record<string, boolean | e.DefinitionNodeExtractor> = {
  Actor: true,
  Gist: e.removeFields([
    "comments",
    "createdAt",
    "files",
    "isFork",
    "isPublic",
    "pushedAt",
    "updatedAt",
    "viewerHasStarred",
  ]),
  GistConnection: e.removeConnectionFieldsExceptTotalCount,
  GitSSHRemote: true,
  HTML: true,
  Language: e.removeNodeAndId,
  Node: true,
  PageInfo: true,
  PinnableItem: true,
  PinnableItemConnection: true,
  PinnableItemEdge: true,
  PinnableItemType: true,
  ProfileOwner: e.removeFields([
    "anyPinnableItems",
    "id",
    "itemShowcase",
    "pinnableItems",
    "pinnedItemsRemaining",
    "viewerCanChangePinnedItems",
  ]),
  Query: e.removeFieldsExcept(["user"]),
  Repository: e.removeInterfacesAndFields(
    ["Node", "PackageOwner", "ProjectOwner", "Subscribable"],
    [
      "assignableUsers",
      "branchProtectionRules",
      "codeOfConduct",
      "collaborators",
      "commitComments",
      "contactLinks",
      "createdAt",
      "databaseId",
      "defaultBranchRef",
      "deleteBranchOnMerge",
      "dependencyGraphManifests",
      "deployKeys",
      "deployments",
      "diskUsage",
      "fundingLinks",
      "hasIssuesEnabled",
      "hasProjectsEnabled",
      "hasWikiEnabled",
      "homepageUrl",
      "id",
      "interactionAbility",
      "isArchived",
      "isBlankIssuesEnabled",
      "isDisabled",
      "isEmpty",
      "isInOrganization",
      "isLocked",
      "isMirror",
      "isPrivate",
      "isSecurityPolicyEnabled",
      "isTemplate",
      "isUserConfigurationRepository",
      "issue",
      "issueOrPullRequest",
      "issueTemplates",
      "issues",
      "label",
      "labels",
      "languages",
      "latestRelease",
      "licenseInfo",
      "lockReason",
      "mentionableUsers",
      "mergeCommitAllowed",
      "milestone",
      "milestones",
      "mirrorUrl",
      "object",
      "openGraphImageUrl",
      "packages",
      "pinnedIssues",
      "project",
      "projects",
      "projectsResourcePath",
      "projectsUrl",
      "pullRequest",
      "pullRequests",
      "pushedAt",
      "rebaseMergeAllowed",
      "ref",
      "refs",
      "release",
      "releases",
      "repositoryTopics",
      "securityPolicyUrl",
      "squashMergeAllowed",
      "submodules",
      "tempCloneToken",
      "templateRepository",
      "updatedAt",
      "usesCustomOpenGraphImage",
      "viewerCanAdminister",
      "viewerCanCreateProjects",
      "viewerCanSubscribe",
      "viewerCanUpdateTopics",
      "viewerDefaultCommitEmail",
      "viewerDefaultMergeMethod",
      "viewerHasStarred",
      "viewerPermission",
      "viewerPossibleCommitEmails",
      "viewerSubscription",
      "vulnerabilityAlerts",
      "watchers",
    ],
  ),
  RepositoryConnection: e.compose(
    e.removeConnectionFieldsExceptTotalCount,
    e.removeFields(["totalDiskUsage"]),
  ),
  RepositoryInfo: e.removeFields([
    "createdAt",
    "hasIssuesEnabled",
    "hasProjectsEnabled",
    "hasWikiEnabled",
    "homepageUrl",
    "isArchived",
    "isInOrganization",
    "isLocked",
    "isMirror",
    "isPrivate",
    "isTemplate",
    "licenseInfo",
    "lockReason",
    "mirrorUrl",
    "openGraphImageUrl",
    "pushedAt",
    "updatedAt",
    "usesCustomOpenGraphImage",
  ]),
  RepositoryOwner: e.removeFields(["repositories", "repository"]),
  StargazerConnection: e.removeConnectionFieldsExceptTotalCount,
  Starrable: e.removeFields(["id", "viewerHasStarred"]),
  URI: true,
  UniformResourceLocatable: true,
  User: e.removeInterfacesAndFields(
    ["PackageOwner", "ProjectOwner", "Sponsorable"],
    [
      "anyPinnableItems",
      "commitComments",
      "contributionsCollection",
      "createdAt",
      "followers",
      "following",
      "gist",
      "gistComments",
      "gists",
      "hasSponsorsListing",
      "hovercard",
      "interactionAbility",
      "isBountyHunter",
      "isCampusExpert",
      "isDeveloperProgramMember",
      "isEmployee",
      "isHireable",
      "isSiteAdmin",
      "isSponsoredBy",
      "isSponsoringViewer",
      "isViewer",
      "issueComments",
      "issues",
      "itemShowcase",
      "organization",
      "organizationVerifiedDomainEmails",
      "organizations",
      "packages",
      "pinnableItems",
      "pinnedItemsRemaining",
      "project",
      "projects",
      "projectsResourcePath",
      "projectsUrl",
      "publicKeys",
      "pullRequests",
      "repositories",
      "repositoriesContributedTo",
      "repository",
      "savedReplies",
      "sponsorsListing",
      "sponsorshipForViewerAsSponsor",
      "sponsorshipsAsMaintainer",
      "sponsorshipsAsSponsor",
      "starredRepositories",
      "topRepositories",
      "updatedAt",
      "viewerCanChangePinnedItems",
      "viewerCanCreateProjects",
      "viewerCanFollow",
      "viewerCanSponsor",
      "viewerIsFollowing",
      "viewerIsSponsoring",
      "watching",
    ],
  ),
  UserStatus: e.compose(
    e.removeNodeAndId,
    e.removeFields([
      "createdAt",
      "expiresAt",
      "indicatesLimitedAvailability",
      "organization",
      "updatedAt",
    ]),
  ),
};

export function extractSchema(ast: gq.DocumentNode): gq.DocumentNode {
  const originalTypes = ast.definitions.filter(gq.isTypeDefinitionNode);

  {
    const originalTypeNames = new Set(originalTypes.map((t) => t.name.value));
    const invalidDefNames = Object.keys(defsToExtract).filter(
      (nodeName) => !originalTypeNames.has(nodeName),
    );
    assert(
      invalidDefNames.length === 0,
      `Only TypeDefinitionNode can be extracted: the following nodes are not TypeDefinitionNode: ${invalidDefNames.join(
        ", ",
      )} `,
    );
  }

  const extractedDefs = originalTypes
    .map((node) => ({
      node,
      extractor: defsToExtract[node.name.value],
    }))
    .filter((n) => n.extractor)
    .map(({ node, extractor }) => {
      if (extractor === true) {
        return node;
      } else if (typeof extractor === "function") {
        return extractor(node);
      } else {
        assert(false, `invalid extractor for ${node.name.value}`);
      }
    })
    .filter(<T>(v: T): v is Exclude<T, null> => !!v);

  return {
    ...ast,
    definitions: extractedDefs,
  };
}
